/*Copyright (c) 2008 Alexander Milde (alexmilde@web.de)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/package de.jvm.next.hid.camera.observer.controller {	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;		/**	 * The blob controller generates rectangles out of a videoframe.	 * <br>	 * The videoframe is monochrome and the controller draws rectangles around the 	 * white / black areas and stores them.	 * <br>	 * Idea: Mario Klingemann	 * 	 * @author Alexander Milde	 */	public class Blob_Controller 	{		private var _blobArr : Array = new Array();		private var _startPt : Point = new Point();		private var _fillClr : uint = 0xff123456;		// track not every blob		//		private var _blobMaxHeight : int;		private var _blobMinWidth : int;		private var _blobMinHeight : int;		private var _blobMaxWidth :int;				public function Blob_Controller(miW : int, maW : int, miH : int, maH : int)		{			_blobMinWidth = miW;			_blobMaxWidth = maW;			_blobMinHeight = miH;			_blobMaxHeight = maH;		}				//		// blob detection		// idea: mario klingemann		// implemented alexander milde		public function createBlobs(_videoFrame : BitmapData, clr : uint) : void		{			_startPt.x = 0;			_startPt.y = 0;			_blobArr = new Array();						while(_startPt.x != -1)			{				fillBlobArr(_videoFrame, clr);			}		}		//		// blob detection		// idea: mario klingemann		// implemented alexander milde		public function fillBlobArr(_videoFrame : BitmapData, clr : uint) : void		{							// sest the fill color			var clr2 : uint = 0xffffffff;			// get current fill color			var tmpClr : uint = _videoFrame.getPixel32(_startPt.x, _startPt.y);			_videoFrame.floodFill(_startPt.x, _startPt.y, clr2);			// get rectangle that was filled			var rect1 : Rectangle = _videoFrame.getColorBoundsRect(0xffffffff, clr2, true);			// fill it with std color so that it wont be tracked again			_videoFrame.floodFill(_startPt.x, _startPt.y, _fillClr);			// get the rectangle where no filling is			var rect2 : Rectangle = _videoFrame.getColorBoundsRect(0xffffffff, _fillClr, false);							//			// alex blob nur zeichnen wenn schwarz :-)				if(tmpClr == clr)			{				if(rect1.width > _blobMinWidth && rect1.width < _blobMaxWidth)				{					if(rect1.height > _blobMinHeight && rect1.height < _blobMaxHeight)					{						_blobArr.push(rect1);								}				}							}						_startPt = findnextPoint(_videoFrame, _fillClr, rect2);		}// ______________________________________________________________________________________________________// 																			 Find next pixel in rectangle//			private function findnextPoint(_picTest : BitmapData, clr : uint, rect : Rectangle) : Point		{			//			// find next pixel in row			var ret : Point = new Point(-1,-1);			var i : int = rect.x;									while(i < rect.x+rect.width)			{				if(_picTest.getPixel32(i, rect.y) != clr)				{					ret.x = i;					ret.y = rect.y;					i = rect.x+rect.width;				}								i++;			}									return ret;		}						public function get blobArr() : Array		{			return _blobArr;		}						public function updateRangeParams(miW : int, maW : int, miH : int, maH : int) : void		{			_blobMinWidth = miW;			_blobMaxWidth = maW;			_blobMinHeight = miH;			_blobMaxHeight = maH;		}	}}