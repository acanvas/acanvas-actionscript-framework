/*Copyright (c) 2008 Alexander Milde (alexmilde@web.de)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/package de.jvm.next.hid.camera.observer.mode {	import de.jvm.next.hid.camera.observer.utils.BitmapDataAnalyser;	import de.jvm.next.hid.camera.observer.utils.BitmapManipulator;	import de.jvm.next.hid.camera.observer.utils.SpecialMath;	import de.jvm.next.hid.camera.observer.video.DynamicVideo;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.filters.ColorMatrixFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * ImageRecognition compares two bitmapdatas. the reference bitmadata is 	 * black and white only. it is compared to a specific bitmapdata out of 	 * the videoframe.	 * 	 * @author Alexander Milde	 */	 	public class ImageRecognition extends Sprite implements IVideoObserver	{		//		private var _camera : DynamicVideo;				private var _tollerance : int = 50;				private var _referenceImagesBoolean : Array = new Array();				private var _refImgBooleanSimilarity : Array = new Array();		//		private var _videoFrame : BitmapData; 		private var _videoPart : BitmapData;		//Bildarray mit booolean werten für schwarz weiß		private var _videoPartBoolean : Array;		private var _searchRect : Rectangle;				private var _mostSimilarImg : Array = new Array();						//		// contrast = 50, saturation = -100, brightness: 0,		// standard configuration brightness can be adjustet by user		private var _brightness : Number = -63;		private var _mat : Array = [0.444384,0.877536,0.11808,0,_brightness,									0.444384,0.877536,0.11808,0,_brightness,									0.444384,0.877536,0.11808,0,_brightness,									0,0,0,1,0];											private var _fClr : ColorMatrixFilter = new ColorMatrixFilter(_mat);		private var _rect : Rectangle;			public function ImageRecognition(camWidth : int, fps : int = 30, width : int = 100, height : int = 100, tollerance : int = 50, searchX : int = 20, searchY : int = 20)		{			_camera = new DynamicVideo(camWidth, fps);			decreaseBrightness();						_tollerance = tollerance;			_searchRect = new Rectangle(searchX, searchY, width, height);			_videoFrame = new BitmapData(_camera.width, _camera.height, false, 0xffffff);			_videoPart = new BitmapData(width, height, false, 0xffffffff);			_rect = new Rectangle(0, 0, _camera.width, _camera.height);		}		/**		 * Setting the difference between the two images.		 * <br>		 * The lower the difference the higher is the similarity of both.		 */		 		public function analyse() : void		{			// drawing the temporary videoframe			_videoFrame.draw(_camera.video);			_videoFrame.draw(BitmapManipulator.reduceColors(_videoFrame, new Rectangle(0, 0, _videoFrame.width, _videoFrame.height), 2));			_videoPart = new BitmapData(_searchRect.width, _searchRect.height, false, 0xffffffff);					// video part in boolean array konvertieren					_videoPart = setVideoPart(_videoFrame, _searchRect);					//			// vergleiche mit allen referenzbildern						var i : int = 0;			var max : int = _referenceImagesBoolean.length;			var val : int = 0;			_refImgBooleanSimilarity = new Array();									while(i < max)			{				val = SpecialMath.compareBooleanArrays(_referenceImagesBoolean[i], _videoPartBoolean);				_refImgBooleanSimilarity.push(val);				i++;			}						_mostSimilarImg = SpecialMath.findMinimum(_refImgBooleanSimilarity);		}				private function setVideoPart(videoFrame : BitmapData, searchRect : Rectangle) : BitmapData		{			var ret : BitmapData = new BitmapData(searchRect.width, searchRect.height, false, 0xffffff);			ret.copyPixels(videoFrame, searchRect, new Point(0,0));			ret.draw(BitmapManipulator.reduceColors(ret, new Rectangle(0, 0, searchRect.width, searchRect.height), 2));						_videoPartBoolean = BitmapDataAnalyser.convertToBooleanArr(ret);			return ret;		}						/**		 * add the reference image<br><br>		 * With a view changes its also possible to compare the videoframe to an		 * array of images.		 */		 		public function addImage(img : Bitmap) : Boolean		{			if(img.width == _searchRect.width && img.height == _searchRect.height)			{				var tmpBmd : BitmapData = new BitmapData(_searchRect.width, _searchRect.height, false, 0xffffffff);				tmpBmd.draw(img);				_referenceImagesBoolean.push(BitmapDataAnalyser.convertToBooleanArr(tmpBmd));				return true;			}			else			 return false;		}		//		// CONFIG AND RETURN VALUES		// ________________________________________________________________________________________________						public function get originalVideoFrame() : BitmapData		{			_camera.applyFilterSet(null);			var _ret : BitmapData = new BitmapData(_camera.width, _camera.height, false, 0xffffff);			_ret.draw(_camera.video);			_camera.applyFilterSet(_fClr);						return _ret;		}				public function increaseBrightness() : void		{			_brightness += 10;			_mat = [0.6172,1.2188,0.164,0,_brightness,					0.6172,1.2188,0.164,0,_brightness,					0.6172,1.2188,0.164,0,_brightness,					0,0,0,1,0];			_fClr = new ColorMatrixFilter(_mat);					_camera.applyFilterSet(_fClr);		}				public function decreaseBrightness() : void		{			_brightness -= 10;			_mat = [0.6172,1.2188,0.164,0,_brightness,					0.6172,1.2188,0.164,0,_brightness,					0.6172,1.2188,0.164,0,_brightness,					0,0,0,1,0];			_fClr = new ColorMatrixFilter(_mat);					_camera.applyFilterSet(_fClr);		}				public function get searchRect() : Rectangle		{			return _searchRect;		}						public function get mostSimilarImg() : Array		{			return _mostSimilarImg;		}						public function set searchRect(searchRect : Rectangle) : void		{			_searchRect = searchRect;		}						public function get brightness() : Number		{			return _brightness;		}						public function get videoFrame() : BitmapData		{			return _videoFrame;		}						public function get videoPartBoolean() : Array		{			return _videoPartBoolean;		}	}}